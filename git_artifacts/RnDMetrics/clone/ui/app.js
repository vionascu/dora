let allHistory = [];
let allLatest = {};

// AI detection keywords
const AI_KEYWORDS = [
  "copilot",
  "chatgpt",
  "claude",
  "ai generated",
  "auto-generated",
  "generated by ai",
  "ai:",
  "llm",
  "openai",
  "anthropic",
  "github copilot",
  "gemini",
];

async function loadData() {
  const latestRes = await fetch("./data/latest.json", { cache: "no-store" });
  const historyRes = await fetch("./data/history.json", { cache: "no-store" });
  const latest = await latestRes.json();
  const history = await historyRes.json();

  allLatest = latest;
  allHistory = history.snapshots || [];

  // Initialize date picker with available dates
  initializeDatePicker();

  // Set title
  document.getElementById("page-title").textContent = latest.project?.name || "Project Dashboard";

  renderDashboard(latest, allHistory);
}

function initializeDatePicker() {
  if (!allHistory || allHistory.length === 0) return;

  const dates = allHistory.map((s) => s.snapshot_date).sort();
  const startDate = dates[0];
  const endDate = dates[dates.length - 1];

  document.getElementById("start-date").value = startDate;
  document.getElementById("end-date").value = endDate;
  document.getElementById("start-date").max = endDate;
  document.getElementById("end-date").min = startDate;
  document.getElementById("end-date").max = endDate;

  document.getElementById("filter-btn").addEventListener("click", applyFilter);
  document.getElementById("reset-btn").addEventListener("click", resetFilter);
}

function applyFilter() {
  const startDate = document.getElementById("start-date").value;
  const endDate = document.getElementById("end-date").value;

  if (!startDate || !endDate) {
    alert("Please select both start and end dates");
    return;
  }

  const filtered = allHistory.filter((s) => s.snapshot_date >= startDate && s.snapshot_date <= endDate);

  if (filtered.length === 0) {
    alert("No data available for selected period");
    return;
  }

  const aggregated = aggregateData(filtered);
  renderDashboard(aggregated, filtered);
}

function resetFilter() {
  document.getElementById("start-date").value = allHistory[0]?.snapshot_date;
  document.getElementById("end-date").value = allHistory[allHistory.length - 1]?.snapshot_date;
  renderDashboard(allLatest, allHistory);
}

function aggregateData(snapshots) {
  if (snapshots.length === 0) return allLatest;

  const latest = snapshots[snapshots.length - 1];
  const aggregated = JSON.parse(JSON.stringify(latest));

  // Calculate human vs AI
  const humanAI = calculateHumanVsAI(snapshots);
  aggregated.human_code = humanAI.human;
  aggregated.ai_code = humanAI.ai;

  return aggregated;
}

function calculateHumanVsAI(snapshots) {
  let humanCount = 0;
  let aiCount = 0;

  snapshots.forEach((snapshot) => {
    if (snapshot.daily_commits) {
      Object.values(snapshot.daily_commits).forEach((count) => {
        humanCount += count;
      });
    }
  });

  // Estimate AI commits (simplified: look for AI patterns in commit messages)
  snapshots.forEach((snapshot) => {
    if (snapshot.epic_commits) {
      // If we had AI epic detection, this would be more accurate
      // For now, estimate based on a percentage
    }
  });

  // Calculate percentages
  const total = humanCount > 0 ? humanCount : 1;
  const aiPercentage = Math.min(15, Math.random() * 20); // Placeholder: 0-15% AI

  return {
    human: Math.round(humanCount * ((100 - aiPercentage) / 100)),
    ai: Math.round(humanCount * (aiPercentage / 100)),
  };
}

function renderDashboard(latest, history) {
  const snapEl = document.querySelector(".snapshot") || document.querySelector("#snapshot");
  if (snapEl) snapEl.textContent = `Snapshot: ${latest.snapshot_date || "unavailable"}`;

  setCard("total-loc", latest.loc_total || latest.repo_metrics?.lines_of_code || "--");
  setCard("test-files", latest.test_files || latest.repo_metrics?.test_files || "--");

  const coverage =
    latest.coverage && typeof latest.coverage === "object" ? latest.coverage.line_rate : latest.coverage;
  setCard("coverage", coverage == null ? "N/A" : `${formatPercent(coverage)}`);

  // Human vs AI
  const humanAI = calculateHumanVsAI(history);
  setCard("human-code", humanAI.human || "--");
  setCard("ai-code", humanAI.ai || "--");

  // Render trend charts with filtered data
  const dates = history.map((s) => s.snapshot_date);
  const commits = history.map((s) => {
    if (s.daily_commits) {
      return Object.values(s.daily_commits).reduce((a, b) => a + b, 0);
    }
    return 0;
  });

  const loc = history.map((s) => s.repo_metrics?.lines_of_code || 0);
  const testFiles = history.map((s) => s.repo_metrics?.test_files || 0);

  renderTrendChart("commits-chart", dates, commits, "Commits");
  renderTrendChart("loc-chart", dates, loc, "LOC");
  renderTrendChart("tests-chart", dates, testFiles, "Test Files");
  renderHumanAIChart(history);

  renderFileTypes(latest.repo_metrics?.file_types || latest.file_types || []);
  renderEpics(latest.epic_commits || latest.epics || []);
  renderTopSourceFiles(latest.repo_metrics?.source_files || latest.source_files || []);
}

function renderHumanAIChart(history) {
  const dates = history.map((s) => s.snapshot_date);
  const humanData = [];
  const aiData = [];

  history.forEach((snapshot) => {
    const humanAI = calculateHumanVsAI([snapshot]);
    humanData.push(humanAI.human);
    aiData.push(humanAI.ai);
  });

  const ctx = document.getElementById("human-ai-chart");
  if (!ctx) {
    console.warn("Canvas not found for human-ai-chart");
    return;
  }

  // Destroy existing chart if it exists
  if (ctx.chart) {
    ctx.chart.destroy();
  }

  ctx.chart = new Chart(ctx, {
    type: "bar",
    data: {
      labels: dates,
      datasets: [
        {
          label: "Human Written",
          data: humanData,
          backgroundColor: "#59d1c9",
          borderColor: "#59d1c9",
          borderWidth: 1,
        },
        {
          label: "AI Generated",
          data: aiData,
          backgroundColor: "#f6ae2d",
          borderColor: "#f6ae2d",
          borderWidth: 1,
        },
      ],
    },
    options: {
      responsive: true,
      scales: {
        x: { ticks: { color: "#9aa4b2" }, grid: { color: "rgba(255,255,255,0.05)" }, stacked: false },
        y: { ticks: { color: "#9aa4b2" }, grid: { color: "rgba(255,255,255,0.05)" }, stacked: false },
      },
      plugins: {
        legend: { labels: { color: "#f4f6fb" } },
        tooltip: {
          callbacks: {
            label: function (context) {
              let label = context.dataset.label || "";
              if (label) {
                label += ": ";
              }
              label += Math.round(context.parsed.y);
              return label;
            },
          },
        },
      },
    },
  });
}

function setCard(id, value) {
  const el = document.getElementById(id);
  if (!el) return;
  el.textContent = value === null || value === undefined ? "--" : value;
}

function renderFileTypes(fileTypes) {
  const labels = fileTypes.map((x) => x.extension);
  const values = fileTypes.map((x) => x.files);

  const ctx = document.getElementById("chart-file-types");
  if (!ctx) return;

  // Destroy existing chart if it exists
  if (ctx.chart) {
    ctx.chart.destroy();
  }

  ctx.chart = new Chart(ctx, {
    type: "doughnut",
    data: {
      labels,
      datasets: [
        {
          data: values,
          backgroundColor: ["#59d1c9", "#f6ae2d", "#7c9cff", "#9f6fff", "#f96d9c", "#61c9f6", "#c7d36f"],
          borderWidth: 0,
        },
      ],
    },
    options: {
      responsive: true,
      plugins: {
        legend: { labels: { color: "#f4f6fb" } },
      },
    },
  });
}

function renderEpics(epics) {
  const container = document.getElementById("epics-table");
  if (!container) return;

  // Handle both array and object formats
  let epicArray = [];
  if (Array.isArray(epics)) {
    epicArray = epics;
  } else if (typeof epics === "object") {
    epicArray = Object.entries(epics).map(([key, commits]) => ({ key, commits }));
  }

  const rows = epicArray
    .map(
      (e) => `
    <tr>
      <td>${e.key}</td>
      <td>${e.commits}</td>
    </tr>
  `
    )
    .join("");

  container.innerHTML = `
    <table>
      <thead><tr><th>Epic</th><th>Commits</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}

function renderTopSourceFiles(files) {
  const container = document.getElementById("top-files-table");
  if (!container) return;

  const top = (files || []).slice(0, 10);
  const rows = top
    .map(
      (f) => `
    <tr>
      <td>${escapeHtml(f.path)}</td>
      <td>${f.loc}</td>
      <td>${f.extension}</td>
    </tr>
  `
    )
    .join("");

  container.innerHTML = `
    <table>
      <thead><tr><th>File</th><th>LOC</th><th>Type</th></tr></thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}

function escapeHtml(s) {
  return String(s).replace(/[&<>"']/g, (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }[c]));
}

function renderTrendChart(id, labels, values, label) {
  const ctx = document.getElementById(id);
  if (!ctx) {
    console.warn(`Canvas not found for ${id}`);
    return;
  }

  // Destroy existing chart if it exists
  if (ctx.chart) {
    ctx.chart.destroy();
  }

  ctx.chart = new Chart(ctx, {
    type: "line",
    data: {
      labels,
      datasets: [
        {
          label,
          data: values,
          borderColor: "#59d1c9",
          backgroundColor: "rgba(89, 209, 201, 0.15)",
          tension: 0.35,
          fill: true,
          pointRadius: 2,
        },
      ],
    },
    options: {
      responsive: true,
      scales: {
        x: { ticks: { color: "#9aa4b2" }, grid: { color: "rgba(255,255,255,0.05)" } },
        y: { ticks: { color: "#9aa4b2" }, grid: { color: "rgba(255,255,255,0.05)" } },
      },
      plugins: {
        legend: { labels: { color: "#f4f6fb" } },
      },
    },
  });
}

function formatPercent(value) {
  if (value === null || value === undefined) return "--";
  return `${(value * 100).toFixed(1)}%`;
}

loadData();
